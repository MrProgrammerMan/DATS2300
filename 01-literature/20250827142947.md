---
title: Forelesning 27.08
id: 20250827143009
tags: []
---

# Forelesning 27.08
## Sortering
### Hvorfor?
Det er lettere å  søke gjennom og finne noe spesifikt hvis det er sortert. Det muliggjør binære trestrukturer for søk i orden $\log_2n$. På samme måte som en ordbok må være sortert alfabetisk for at man effektivt skal kunne finne ordet man leter etter.

### Hvordan?
Det finnes mange måter å sortere noe. I denne forelesningen skal vi se på noen metoder for å sortere en liste med tall i stigende rekkefølge.

[Sist]([[20250818122515]]) så vi hvordan vi kan finne den største verdien i en liste. Dersom vi tar denne største verdien og setter bakerst har vi gjort listen nærmere sortert. Vi kan gjenta dette til listen er sortert. Dette kalles for _utvalgssortering_.

Eksempel implementering:
```rust
fn min(tabell: &[i32], fra: usize, til: usize) -> usize {
	let mut min = fra;
	for i in fra..til {
		if tabell[i] < tabell[min] {
			min = i;
		}
	}
	min
}
```

```rust
fn utvalgs_sortering(tabell: &mut Vec<i32>) {
	let mut minste_posisjon;
	for i in 0..tabell.len() {
		minste_posisjon = min(&tabell, i, tabell.len());
		tabell.swap(i, minste_posisjon);
	}
}
```

## Inversjoner
Gitt en permutasjon av heltall:

$$
1 \ 2 \ 4 \ 3 \ 6 \ 7 \ 9 \ 5 \ 8 \ 10
$$
Sier vi at et par $(x, y)$ der $x$ ligger til venstre for $y$ og $x$ er større enn $y$ er i utakt og derfor kalles en **inversjon**.
**Definisjon**: En liste er _sortert_ hvis den ikke har noen inversjoner. For å sortere en liste prøver vi å minke antall inversjoner.

Påstand: Hvis vi har en liste med inversjoner må minst én av inversjonene være mellom tall ved siden av hverandre.

### En naiv sorteringalgoritme
Basert på målet om å minske inversjoner kan vi lage en enkel sorteringsalgoritme som benytter seg av at det må være inversjoner mellom tall ved siden av hverandre.

Vi går gjennom listen og ser etter inversjoner mellom par av tall ved siden av hverandre.
Hver gang vi finner en inversjon, bytter vi om på tallene for å fjerne inversjonen. Vi fortsetter med dett til vi kan gå gjennom hele listen uten en eneste inversjon.

#### Implementasjon
```rust
fn boble_sorterig(tabell: &mut Vec<i32>) {
    let mut fant_inversjon = true;
    while fant_inversjon {
    	fant_inversjon = false;
        for i in 0..tabell.len()-1 {
            if tabell[i] > tabell[i+1] {
                tabell.swap(i, i+1);
                fant_inversjon = true;
            }
        }
    }
}
```