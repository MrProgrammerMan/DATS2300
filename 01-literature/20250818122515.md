---
title: Forelesning 18.8
id: 20250818122541
tags: [praktisk info, oblig]
---

# [Forelesning]([[20250818100422]]) 18.8
## Praktisk info
3 obliger:
- Gruppeoppgave 1 (1-5 pers)
- Gruppeoppgave 2 (1-5 pers)
- Individuell

Obligene leveres via GitHub Classroom. Tester skal passere for godkjent oblig.

---

Eksamen er 3t skriftlig. ⅓ er multiple-choice, ⅔ er langsvars.
NB!: _kun eksamen 2024 er 3t, de eldre eksamenene er 2t_
**Kun kalkulator som hjelpemidler på eksamen** I fjor var det lov med alle trykte og skrevne hjelpemidler.
Minst én oppgave på eksamen kommer til å bli tatt fra en oblig.

---

Øvingstimer begynner uke 35. Uke 35 og 36 er det kun øving tirsdag. Etter det er det øving tirsdag og fredag.

---

Læreboka ligger ute, finnes i Canvas.
Løsningsforslag til oppgavene er på blå knapp.

## Pensum i dag
- Hva er en algoritme?
- Hvorfor bryr vi oss?

### Hva er en algoritme?
En algoritme er en oppskrift som beskriver konkrete og veldefinerte trinn som løser et problem. Algoritmer har eksistert lenge, men har blitt veldig relevante i eraen av datamaskiner. Vi har:
- et problem som vi ønsker å løse.
- en algoritme, som beskriver hvordan vi løser problemet.
- en implementasjon av algoritmen, som er algoritmen satt ut i livet i virkeligheten, gjerne i et programmeringsspråk (som rust).

Problemet formuleres gjerne som et forhold mellom input-data og output-data.
Algoritmen tar utgangspunkt i input-dataen og formulerer trinnvis hvordan dette transformeres til output-dataen.
Implementasjonen er den konkrete koden som utfører algoritmen. Her tar vi hensyn til "andre ting" som maskinen vi kjører koden på, ting programmeringsspråket krever at vi tenker på, osv. For eksempel bestemmer vi variabelnavn. Her er det litt valg vi kan/må ta avhengig av språk, platform, krav, osv.

### Eksempel

#### Problem
Vi har en tabell med tall. VI vil finne det største tallet i tabellen.
Input: En tabell med tall.
Output: Det største tallet i tabellen.

#### Algoritme
Under er to forslag på algoritmer

##### Algoritme, alternativ 1
Sorter tabellen, slik at det største tallet er først.

##### Algoritme, alternativ 2
Gå gjennom tabellen og husk det største tallet som er sett til nå. Til sist husker vi det største tallet i tabellen.

Vi ser at alternativ 1 også sorterer tabellen, noe som er unødvendig for å løse problemet. Derfor er sannsynligvis alternativ 2 en bedre algoritme for dette problemet. Det er imidlertid viktig å merke seg at begge algoritmer er _korrekte_, dvs. de gir riktig svar og går ikke for evig uten å stanse.

#### Implementasjon
Et eksempel på alternativ 1 implementert i rust:
```rust
fn algoritme_sorterer(nums: Vec<i32>) -> i32 {
    nums.sort();
    nums[0]
}
```

Et eksempel på alternativ 2 implementert i rust:
```rust
fn algoritme_lokke(nums: &[i32]) -> usize {
    let mut maks = nums[0];
    for i in 1..nums.len() {
        if nums[i] > maks {
            maks = nums[i]
        }
    }
    maks
}
```

### Hva gjør en algoritme bra?
Det finnes flere måter å måle om en algoritme er "bra", vist under.
| Mål på "bra-het"            | Forklaring                                                                                                                                                                                               |
|-----------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Hastighet                   | Hvor raskt utfører algoritmen oppgaven sin? (skal defineres mer nøyaktig senere).                                                                                                                        |
| Minnebruk                   | Hvor mye minne algoritmen bruker under kjøring.                                                                                                                                                          |
| Destruktivitet              | Algoritmen endrer på input-dataen sin.                                                                                                                                                                   |
| Pålitelighet                | Noen algoritmer gir riktig svar *mesteparten* av tiden, men ikke **alltid**. Det å sjekke med 100% sikkerhet om et tall er et primtall kan gjøres mye raskere dersom man ikke trenger 100% pålitelighet. |
| Nøyaktighet                 | Kan algoritmen estimere et svar som er nært det ekte svaret? En algoritme kan garantert finne et tall blant topp 3 største tall i en tabell, men ikke nødvendigvis det største.                          |
| Forståelighet               | En forståelig algoritme øker sjansen for at den kodes riktig og at andre kan forstå hvorfor algoritmen fungerer.                                                                                         |
| Implementeringskompleksitet | Hvor lang tid tar det å implementere algoritmen?                                                                                                                                                         |

Man må ofte balansere punktene over etter situasjonen man designer en algoritme for. En raskere algoritme kan være optimalisert på måter som gjør den vanskeligere å forstå.

#### Hastighet
Hastighet er en av de mest brukte måtene å måle en algoritme på. Men hvordan måler vi hastighet?
Det er generelt to måter:
1. Vi tester hastigheten ved å kjøre algoritmen og måle.
    - Vi må ha et representativt testproblem.
2. Vi ønsker et teoretisk grunnlag for å bestemme hvor rask en algoritme er.
    - Vi regner ut antallet grunnleggende operasjoner som utføres av algoritmen for å fjerne avhengigheten av hvor raskt disse operasjonene utføres på en bestemt maskin.
    - Antallet operasjoner er vanligvis avhengig av størrelsen på input-dataen. Vi finner derfor en formel som gir antall operasjoner som et uttrykk i \(n\), størrelsen på input-dataen.

##### Regne antall operasjoner
Vi ser på alternativ 2 fra tidligere (lineær søk etter maksimum).
```rust
fn algoritme_lokke(nums: &[i32]) -> usize {
    let mut maks = nums[0]; // 2 operasjoner: hent nums[0] og lagre i maks
    for i in 1..nums.len() { // gjentas n-1 ganger
        // 1 operasjon: oppdater i (loop-iterasjon)
        if nums[i] > maks { // 2 operasjoner: hent nums[i] og sammenlign med maks
            maks = nums[i] // 0 eller 2 operasjoner: hent nums[i] og oppdater maks
        }
    }
    maks // 1 operasjon: returner maks
}
```

Totalt blir antall operasjoner
$$2 + (n-1)\cdot(1+2+x)+1$$
hvor $x$ er enten $0$ eller $2$ avhengig av om if-testen slår ut.

- Dersom $x=0$ alltid (best case), får vi
$$2 + (n-1)\cdot(1+2+0)+1 = 3n$$
- Dersom $x=2$ alltid (worst case), får vi
$$2 + (n-1)\cdot(1+2+2)+1 = 5n - 2$$

Best-case: $3n$ operasjoner.  
Worst-case: $5n-2$ operasjoner.

Vi kan også forsøke å finne en _average-case_ for hvor mange ganger if-testen vil inntreffe for en input. Dette er langt mer upraktisk og tidkrevende.  
Vi sier at formelen for antall operasjoner er:
$$3n + 2\cdot k$$  
hvor $k$ er antall oppdateringer av maksverdien, som ligger mellom $0$ og $n-1$.

Spørsmålet blir altså:  
For en gjennomsnittlig liste, **hvor mange oppdateringer** ($k$) må utføres?

##### Utledning av $k$ ved harmoniske tall
Vi jobber oss oppover for ulike størrelser av input $n$:

- **$n = 1$**  
  Mulige tabeller: $\{1\}$  
  $k = 0$

- **$n = 2$**  
  Mulige tabeller: $\{1, 2\}$ $(k = 1)$, $\{2, 1\}$ $(k = 0)$  
  Gjennomsnitt:  
  $$k = \frac{1 + 0}{2} = \frac{1}{2}$$  

- **$n = 3$**  
  Mulige tabeller:  
  $\{1, 2, 3\}$ $(k = 2)$  
  $\{1, 3, 2\}$ $(k = 1)$  
  $\{2, 1, 3\}$ $(k = 1)$  
  $\{2, 3, 1\}$ $(k = 1)$  
  $\{3, 1, 2\}$ $(k = 0)$  
  $\{3, 2, 1\}$ $(k = 0)$  
  Gjennomsnitt:  
  $$k = \frac{2 + 1 + 1 + 1 + 0 + 0}{6} = \frac{5}{6}$$

Hvis vi hadde fortsatt å gjøre dette hadde vi sett at:
$$k = \sum_{i=2}^n \frac{1}{i}$$

Det harmoniske tallet $H_n$ er definert som:  
$$H_n = 1 + \frac{1}{2} + \frac{1}{3} + \dots + \frac{1}{n}$$  

For en liste av størrelse $n$, er gjennomsnittlig antall oppdateringer:  
$$k = H_n - 1$$  

##### Average-case formel
Ved å bruke dette resultatet, kan vi uttrykke average-case som:  
$$3n + 2\cdot k = 3n + 2\cdot (H_n - 1)$$  
$$= 3n + 2\cdot H_n - 2$$  

**Average-case:**
$$3n + 2\cdot H_n - 2$$  

Neste forelesning: Big-O-notasjon.
- Hva er størrelsesordenen til antall operasjoner som må utføres? Mer interressert i det enn i nøyaktig antall.