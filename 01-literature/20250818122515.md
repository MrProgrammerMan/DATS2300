---
title: Forelesning 18.8
id: 20250818122541
tags: [praktisk info, oblig]
---

# Forelesning 18.8
## Praktisk info
3 obliger:
- Gruppeoppgave 1 (1-5 pers)
- Gruppeoppgave 2 (1-5 pers)
- Individuell

Obligene leveres via GitHub Classroom. Tester skal passere for godkjent oblig.

---

Eksamen er 3t skriftlig. ⅓ er multiple-choice, ⅔ er langsvars.
NB!: _kun eksamen 2024 er 3t, de eldre eksamenene er 2t_
**Kun kalkulator som hjelpemidler på eksamen** I fjor var det lov med alle trykte og skrevne hjelpemidler.
Minst én oppgave på eksamen kommer til å bli tatt fra en oblig.

---

Øvingstimer begynner uke 35. Uke 35 og 36 er det kun øving tirsdag. Etter det er det øving tirsdag og fredag.

---

Læreboka ligger ute, finnes i Canvas.
Løsningsforslag til oppgavene er på blå knapp.

## Pensum i dag
- Hva er en algoritme?
- Hvorfor bryr vi oss?

### Hva er en algoritme?
En algoritme er en oppskrift som beskriver konkrete og veldefinerte trinn som løser et problem. Algoritmer har eksistert lenge, men har blitt veldig relevante i eraen av datamaskiner. Vi har:
- et problem som vi ønsker å løse.
- en algoritme, som beskriver hvordan vi løser problemet.
- en implementasjon av algoritmen, som er algoritmen satt ut i livet i virkeligheten, gjerne i et programmeringsspråk (som rust).

Problemet formuleres gjerne som et forhold mellom input-data og output-data.
Algoritmen tar utgangspunkt i input-dataen og formulerer trinnvis hvordan dette transformeres til output-dataen.
Implementasjonen er den konkrete koden som utfører algoritmen. Her tar vi hensyn til "andre ting" som maskinen vi kjører koden på, ting programmeringsspråket krever at vi tenker på, osv. For eksempel bestemmer vi variabelnavn. Her er det litt valg vi kan/må ta avhengig av språk, platform, krav, osv.

### Eksempel

#### Problem
Vi har en tabell med tall. VI vil finne det største tallet i tabellen.
Input: En tabell med tall.
Output: Det største tallet i tabellen.

#### Algoritme
Under er to forslag på algoritmer

##### Algoritme, alternativ 1
Sorter tabellen, slik at det største tallet er først.

##### Algoritme, alternativ 2
Gå gjennom tabellen og husk det største tallet som er sett til nå. Til sist husker vi det største tallet i tabellen.

Vi ser at alternativ 1 også sorterer tabellen, noe som er unødvendig for å løse problemet. Derfor er sannsynligvis alternativ 2 en bedre algoritme for dette problemet. Det er imidlertid viktig å merke seg at begge algoritmer er _korrekte_, dvs. de gir riktig svar og går ikke for evig uten å stanse.

#### Implementasjon
Et eksempel på alternativ 1 implementert i rust:
```rust
fn algoritme_sorterer(nums: Vec<i32>) -> i32 {
    nums.sort();
    nums[0]
}
```

Et eksempel på alternativ 2 implementert i rust:
```rust
fn algoritme_lokke(nums: &[i32]) -> usize {
    let mut maks = nums[0];
    for i in 1..nums.len() {
        if nums[i] > maks {
            maks = nums[i]
        }
    }
    maks
}
```

### Hva gjør en algoritme bra?
Det finnes flere måter å måle om en algoritme er "bra", vist under.
| Mål på "bra-het"            | Forklaring                                                                                                                                                                                               |
|-----------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Hastighet                   | Hvor raskt utfører algoritmen oppgaven sin? (skal defineres mer nøyaktig senere).                                                                                                                        |
| Minnebruk                   | Hvor mye minne algoritmen bruker under kjøring.                                                                                                                                                          |
| Destruktivitet              | Algoritmen endrer på input-dataen sin.                                                                                                                                                                   |
| Pålitelighet                | Noen algoritmer gir riktig svar *mesteparten* av tiden, men ikke **alltid**. Det å sjekke med 100% sikkerhet om et tall er et primtall kan gjøres mye raskere dersom man ikke trenger 100% pålitelighet. |
| Nøyaktighet                 | Kan algoritmen estimere et svar som er nært det ekte svaret? En algoritme kan garantert finne et tall blant topp 3 største tall i en tabell, men ikke nødvendigvis det største.                          |
| Forståelighet               | En forståelig algoritme øker sjansen for at den kodes riktig og at andre kan forstå hvorfor algoritmen fungerer.                                                                                         |
| Implementeringskompleksitet | Hvor lang tid tar det å implementere algoritmen?                                                                                                                                                         |

Man må ofte balansere punktene over etter situasjonen man designer en algoritme for. En raskere algoritme kan være optimalisert på måter som gjør den vanskeligere å forstå.

#### Hastighet
Hastighet er en av de mest brukte måtene å måle en algoritme. Men hvorda måler vi hastighet?
Det er generelt to måter:
1. Vi tester hastigheten ved å kjøre algoritmen og måle.
    - Vi må ha et representativt testproblem.
2. Vi ønsker oss et teoretisk grunnlag for å bestemme den raskeste algoritmen.
    - Vi kan regne ut antallet grunnleggende operasjoner som utføres av algoritmen for å fjerne variablen av hvor fort disse operasjonene blir utført.
    - Antallet operasjoner er vanligvis avhengig av størrelsen på input-dataen. Vi finner derfor en formel som gir antall operasjoner som et uttrykk med n, størrelsen på input-dataen.

##### Regne antall operasjoner
Vi ser på alternativ 2 over.
```rust
fn algoritme_lokke(nums: &[i32]) -> usize {
    let mut maks = nums[0]; // 2 operasjoner: Hent ut nums[0] og lagre i maks
    for i in 1..nums.len() { // Gjør n-1 ganger:
        // 1 operasjon: oppdater i (skrevet i løkke-definisjon)
        if nums[i] > maks { // 2 operasjoner: Hent ut nums[i] og sammenlign med maks
            maks = nums[i] // 0 eller 2 ganger: hent nums[i] og oppdater maks
        }
    }
    maks // Returner maks
}
```

Totalt blir antall operasjoner $ 2 + (n-1) * (1 + 2 + x) $ hvor x er 0 eller 2 avhengig av om if-testen slår ut.
Dersom x **alltid** er 0, blir antall operasjoner $ 2 + (n-1) * (1 + 2 + 0) = 2 + 3n - 3 = 3n - 1 $.
Dersom x **alltid** er 2, blir antallet operasjoner $ 2 + (n-1) * (1 + 2 + 2) = 2 + 5n - 5 = 5n - 3 $.

Dette gir oss altså en _best-case_ og en _worst-case_ for antall operasjoner algoritmen utfører.
Best-case: $ 3n - 1 $ operasjoner,
Worst-case: $ 5n - 3 $ operasjoner,
hvor n er antall elementer i input-tabellen.

Vi kan også forsøke å finne en _average-case_ for hvor mange ganger if-testen vil inntreffe for en input. Dette er langt mer upraktisk og tidkrevende.
Vi sier at formelen for antall iterasjoner er $ 3n - 1 + 2*(k) $, hvor k er antall oppdateringer av maksverdien mellom 0 og n-1.

Spørsmålet blir altså;
For en gjennomsnittlig liste, **hvor mange oppdateringer**(k) må utføres?

Vi jobber oss oppover for størrelser av input n:

n = 1
Mulige tabeller: {1}, k = 0

n = 2
Mulige tabeller: {1, 2}(k = 1), {2, 1}(k=1), k = (1-2)/2 = ½

n = 3
Mulige tabeller:
- {1, 2, 3} (k=2)
- {1, 3, 2} (k=1)
- {2, 1, 3} (k=1)
- {2, 3, 1} (k=1)
- {3, 1, 2} (k=0)
- {3, 2, 1} (k=0)
k = (2+1+1+1)/6 = 5/6

Det viser seg at k er avhengig av det harmoniske tallet H_n: k = H_n - 1

Average case gis altså som 3n-1 + H_n - 1 = 3n + H_n - 2

Neste forelesning: Big-O-notasjon.
- Hva er størrelsesordenen til antall operasjoner som må utføres? Mer interressert i det enn i nøyaktig antall.