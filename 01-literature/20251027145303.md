---
title: Kap 1.1.10 Måling av tidsforbruk
id: 20251027145315
tags: []
---

# [Kap 1.1.10]([[20250818102829]]) Måling av tidsforbruk
For å velge eller optimalisere en algoritme er vi nødt til å kunne måle ytelsen på et eller annet vis. Den letteste måten å gjøre dette(dersom vi sammenligner tidsbruk) er å kjøre algoritmene på samme maskin å måle det reelle tidsbruket av algoritmene. Dette er ikke verre enn å sjekke det nøyaktige tidspunktet(noe som er trivielt i moderne programmeringsspråk) før og etter at man tester algortimen. Dersom algoritmen er for rask til å måles nøyaktig kan vi kjøre den mange ganger eller øke input-størrelsen.
Et eksempel av måling av tidsbruk i java:
```java
public class TimeMeasurementExample {
    public static void main(String[] args) {
        // Start målingen (i nanosekunder for høy presisjon)
        long startTime = System.nanoTime();

        // Kjør algoritmen som skal måles
        long sum = 0;
        for (int i = 0; i < 1_000_000; i++) {
            sum += i;
        }

        // Stopp målingen
        long endTime = System.nanoTime();

        // Beregn og skriv ut tidsforbruket i millisekunder
        double elapsedTimeMs = (endTime - startTime) / 1_000_000.0;
        System.out.printf("Algoritmen brukte %.3f ms%n", elapsedTimeMs);
    }
}
```

## Fallgruver
Ofte vil denne måten å måle tid fungere godt å gi et bra grunnlag for sammenligning av forskjellige algoritmer. Det er imidlertid viktig å være klar over at det er noen fallgruver som kan minke nøyaktigheten av målingene eller gi misvisende resultater. Listen under er ikke uttømmende.

### Tilfeldig variasjon
**Problem:** Dersom vi kjører en algoritme én gang med ett sett med input kan det variere fra gang til gang hvor mye tidsbruk vi måler.
**Løsning:** Vi kjører algoritmene vi tester mange ganger og med forskjellig input data. Det kan lønne seg å generere noen hundre tilfeldige input-sett til dette.

### Input er ikke representativt
- [ ] **Problem:** Dataen vi bruker som input for å teste algoritmene våre gir kanskje et annet resultat enn vi ville sett i et virkelig scenario, hvor dataen er annerledes.
**Løsning:** Vi er nødt til å vurdere om visse typer/kombinasjoner av data er vanligere enn andre i virkeligheten å teste med dette. Dersom det er komplisert må vi kanskje analysere dette i forkant av testingen eller teste med virkelig data.

### Kompilatoroptimalisering
Avhengig av hvilket språk man programmerer i kan det være at kompilatoren har avanserte optimaliseringsteknikker hvis den gjenkjenner visse situasjoner. Dette kan spesielt inntreffe i kunstige og urealistiske situasjoner som f.eks. hvis vi ber om å sortere den samme listen 1000 ganger. I virkeligheten vil vi selvfølgelig at alt som kan skal optimaliseres, men det _kan_ ødelegge testresultater. Noen språk er _lazy_ som kan ha noen merkelige effekter ved måling av tidsbruk.