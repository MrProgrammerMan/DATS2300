---
title: Forelesning 01.09
id: 20250901123253
tags: []
---

# Forelesning 01.09
Sist snakket vi om 3 sorteringsalgoritmer. Problemet med disse var at de alle var av orden $n^2$. Dette vil si at hvis input-størrelsen dobles, 4-dobles tiden algoritmen tar å utføre. Dette gjør slike algoritmer ugunstige for å sortere stor input-data.

## Partisjonering og sortering - quicksort
Partisjonering: tenk partering, men delt i kategorier.
Vi ønsker å partisjonere en liste. Det vil si at vi deler listen i 2 deler basert på hvorvidt gjenstandene i listen tilfredstiller en egenskap eller ikke.

### Hvordan partisjonere
Flere metoder:
- Rett frem
    1. Lag en resultattabell med samme størrelse som input
    2. Gå gjennom tabellen
    3. Skriv opp alle vokaler
    4. Gå gjennom tabellen
    5. Skriv opp alle konsonanter
- Én løkke
    1. Lag en resultattabell med samme størrelse som input 
    2. Gå gjennom tabellen
    3. Sett vokaler forrest
    4. Sett konsonanter bakerst

Begge metodene over har det samme problemet; vi må lage en ny liste for å legge resultatet i. Dette krever minne.
- In place
    1. Let gjennom starten av listen til man finner en verdi på feil plass
    2. Let gjennom slutten av listen bakover til man finner en verdi på feil plass
    3. Bytt verdiene
    4. Flytt begge "pekere" et hakk innover mot midten av listen og gjenta
    5. 

### Eksempel
Vi kan dele opp en liste med bokstaver i vokaler og konsonanter.
Når vi velger å partisjonere listen på dette, er det viktig at vi kan bestemme hvorvidt n gjenstand i listen er en vokal eller ikke for alle gjenstander. Man kan partisjonere i flere deler enn 2, men her holder vi oss til ja/nei-kategorisering.

```rust
/// In-place quicksort implementation.
/// Works directly on a mutable slice (`&mut [T]`),
/// so it avoids allocating new vectors during recursion.
fn quicksort<T: Ord>(slice: &mut [T]) {
    // Base case: slices of length 0 or 1 are already sorted
    if slice.len() <= 1 {
        return;
    }

    // Partition step: rearrange the slice so that
    // - elements <= pivot are on the left,
    // - elements > pivot are on the right.
    let pivot_index = partition(slice);

    // Recursively sort the two partitions.
    // We must avoid including the pivot again.
    let (left, right) = slice.split_at_mut(pivot_index);
    quicksort(left);
    quicksort(&mut right[1..]); // skip pivot
}

/// Partition the slice around the first element as pivot.
/// Returns the final index of the pivot after partitioning.
fn partition<T: Ord>(slice: &mut [T]) -> usize {
    let len = slice.len();
    let pivot_index = 0; // first element as pivot
    slice.swap(pivot_index, len - 1); // move pivot to end temporarily

    let mut store_index = 0;
    for i in 0..len - 1 {
        if slice[i] <= slice[len - 1] {
            slice.swap(i, store_index);
            store_index += 1;
        }
    }

    slice.swap(store_index, len - 1); // move pivot into correct position
    store_index
}

fn main() {
    let mut nums = vec![33, 2, 52, 106, 73, 10, 7, 42];
    println!("Original: {:?}", nums);

    quicksort(&mut nums);

    println!("Sorted:   {:?}", nums);
}

```

```rust
/// A functional (recursive, allocation-based) implementation of quicksort.
/// 
/// Instead of sorting the array in place, this version:
/// - takes a borrowed slice (`&[T]`)
/// - returns a newly allocated, sorted `Vec<T>`.
/// 
/// This style emphasizes clarity and immutability, at the cost of performance
/// (extra allocations happen at each recursion step).
fn quicksort<T: Ord + Clone>(list: &[T]) -> Vec<T> {
    // Base case: if the list has 0 or 1 element, it’s already sorted.
    if list.len() <= 1 {
        return list.to_vec();
    }

    // Choose the first element as the pivot.
    let pivot = &list[0];

    // Partition the rest of the list into two groups:
    // - `less`: elements <= pivot
    // - `greater`: elements > pivot
    //
    // `iter()` gives us an iterator over borrowed items.
    // `cloned()` copies each element (since T: Clone).
    // `partition()` splits them into two Vec<T> in one pass.
    let (less, greater): (Vec<T>, Vec<T>) = list[1..]
        .iter()
        .cloned()
        .partition(|x| x <= pivot);

    // Recursively sort the "less" partition.
    let mut result = quicksort(&less);

    // Add the pivot back in the middle.
    result.push(pivot.clone());

    // Recursively sort the "greater" partition and append it.
    result.extend(quicksort(&greater));

    result
}

fn main() {
    let nums = vec![33, 2, 52, 106, 73, 10, 7, 42];
    let sorted = quicksort(&nums);

    println!("Original: {:?}", nums);
    println!("Sorted:   {:?}", sorted);
}
```