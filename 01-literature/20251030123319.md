---
title: Kap 1.5.2 Hva skjer når en rekursiv metode kjøres?
id: 20251030123345
tags: []
---

# [Kap 1.5.2]([[20250818102829]]) Hva skjer når en rekursiv metode kjøres?
## Datamaskinen
En datamaskin har grunnleggende en prosessor som utfører operasjoner og minne som lagrer instruksjoner og data. Dette minnet er kun et sted man kan lagre tall, men i høy-nivå programmering er ofte minnet delegert til forskjellige formål og med forskjellige egenskaper.

Vi skiller _stack_-minne og _heap_-minne. I stack-minne lagres data som er av en kjent størrelse. En stack er en datastruktur hvor ny data legges på toppen og data tas av fra toppen. Dette er den eneste måten vi kan bruke en stack. Det funker litt som en stabel tallerkener.

## Program-stacken
Et program lagrer vanligvis mye data i en stack som tilhører programmet. Funksjonskall og parametere lagres i denne call-stacken. Dette vil si at når et funksjon kalles legges dette funksjonskallet på toppen, og denne dataen må tas av før funksjonskallet et lag opp(tidligere) kan fortsette.

### Heapen
Stacken kan inneholde pekere til ustrukturert minne i heapen, men dette er ikke relevant for å forstå rekursjon(arrays kan ikke vokse fordi de ligger i stacken, mens ArrayList ligger på heapen. Dette gir mening når man husker på at dataen på stacken kun kan legges på og tas av, den kan ikke endre størrelse).

## Aktivitetslag
Vi sier at callstacken har lag med funksjoner som kalles. Vi begynner med lag 0, som er kallet til main-metoden(i Java i hvert fall). I main kalles kanskje metode a, som kaller metode b, som kaller metode c. Når vi er inne i metode c har stacken 4 lag; 0: main, 1: a, 2: b og 3: c. Etter at c er ferdig tas den av stacken og vi har nå 3 lag. På denne måten holder datamaskinen kontroll på hvilke metoder som kalles og hvor koden fortsetter når vi "hopper inn og ut av funksjoner".

## Rekursjon
Når vi har en rekursiv metode har vi altså potensielt veldig mange slike funksjonskall som må legges i call-stacken. Det er her det forøkte minnebruket kommer fra. I en metode med ett rekursivt tall er det relativt enkelt å forestille seg disse lagene. I en metode med flere rekursive kall(som fibonacci) kan det være langt mer komplisert. Dette kan sammenlignes litt med hvordan det kan være komplisert å forstå iterative løsninger på rekursive problemer. Eksempelvis er den iterative implementasjonen av [quicksort]([[20251028131153]]) ofte gjort ved å rett og slett bruke en egen stack. På sett og vis kan man jo si at dette bare er rekursjon, som i datamaskinen oversettes til nettopp nedbryting av problemet med en rød tråd i callstacken.
Tradisjonell quicksort:
```java
public static void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pivotIndex = partition(arr, low, high);
        quickSort(arr, low, pivotIndex - 1);  // Recurse on left part
        quickSort(arr, pivotIndex + 1, high); // Recurse on right part
    }
}

private static int partition(int[] arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;

    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr, i, j);
        }
    }
    swap(arr, i + 1, high);
    return i + 1;
}

private static void swap(int[] arr, int i, int j) {
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}
```
Quicksort med stack:
```java
public static void quickSort(int[] arr) {
    Stack<int[]> stack = new Stack<>();
    stack.push(new int[]{0, arr.length - 1});

    while (!stack.isEmpty()) {
        int[] range = stack.pop();
        int low = range[0];
        int high = range[1];

        if (low < high) {
            int pivotIndex = partition(arr, low, high);
            // Push right and left subarrays
            stack.push(new int[]{low, pivotIndex - 1});
            stack.push(new int[]{pivotIndex + 1, high});
        }
    }
}

private static int partition(int[] arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;

    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr, i, j);
        }
    }
    swap(arr, i + 1, high);
    return i + 1;
}

private static void swap(int[] arr, int i, int j) {
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}
```
Det er ikke mulig å implementere quicksort iterativt uten en form for lokal lagring som en stack. Man kan vri og vende på problemet med andre former for lagring, og til og med bruke en konstant mengde lagring(man bare grunnet minnebegrensninger i den virkelige verden).