---
title: Kap 1.4.4 Hvordan implementere et generisk grensesnitt?
id: 20251028182241
tags: []
---

# [1.4.4]([[20250818102829]]) Hvordan implementere et generisk grensesnitt?

NÃ¥r man **implementerer et generisk grensesnitt** (f.eks. Comparable<T>), mÃ¥ man sÃ¸rge for **konsistens mellom compareTo(), equals() og hashCode()**.  
Det betyr blant annet at:
- `x.compareTo(y) == 0` mÃ¥ gi samme resultat som `x.equals(y) == true`.  
- `hashCode()` mÃ¥ vÃ¦re konsistent med `equals()`.  

Dette er viktig for at objektene skal kunne brukes korrekt i generiske algoritmer, sortering, hash-baserte samlinger m.m.

---

### Kort eksempel: Heltall
```java
public final class Heltall implements Comparable<Heltall> {
    private final int verdi;

    public Heltall(int verdi) { this.verdi = verdi; }
    public int intVerdi() { return verdi; }

    @Override
    public int compareTo(Heltall h) {
        return verdi < h.verdi ? -1 : (verdi == h.verdi ? 0 : 1);
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof Heltall)) return false;
        return verdi == ((Heltall) o).verdi;
    }

    @Override
    public int hashCode() { return 31 + verdi; }

    @Override
    public String toString() { return Integer.toString(verdi); }
}
```
ğŸ”¹ **Forklaring:**  
`compareTo()` definerer den naturlige ordningen (stigende etter verdi).  
`equals()` og `hashCode()` er gjort konsistente.  
Dette gjÃ¸r at klassen kan brukes i generiske sorteringsalgoritmer som f.eks. `Tabell.innsettingssortering()` eller `Arrays.sort()`.

---

### Kort eksempel: Person
```java
public class Person implements Comparable<Person> {
    private final String fornavn;
    private final String etternavn;

    public Person(String fornavn, String etternavn) {
        this.fornavn = fornavn;
        this.etternavn = etternavn;
    }

    @Override
    public int compareTo(Person p) {
        int cmp = etternavn.compareTo(p.etternavn);
        if (cmp != 0) return cmp;
        return fornavn.compareTo(p.fornavn);
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof Person)) return false;
        return compareTo((Person)o) == 0;
    }

    @Override
    public int hashCode() {
        return Objects.hash(etternavn, fornavn);
    }

    @Override
    public String toString() {
        return fornavn + " " + etternavn;
    }
}
```
ğŸ”¹ **Forklaring:**  
Personer sammenlignes **leksikografisk** (etternavn â†’ fornavn).  
Det betyr at sammenligningen skjer **ledd for ledd**, som i ordbÃ¸ker.

---

### Kort definisjon: leksikografisk ordning
En **leksikografisk ordning** betyr at man sammenligner verdier _leddvis_, der hvert ledd har sin egen ordning.  
F.eks. for personer sammenlignes fÃ¸rst etternavn, og hvis de er like, sammenlignes fornavn.  
Dette tilsvarer hvordan ord sorteres alfabetisk i en ordbok.

---

### Kort eksempel med streams
```java
Person[] personer = {
    new Person("Kari", "Svendsen"),
    new Person("Boris", "Zukanovic"),
    new Person("Ali", "Kahn"),
    new Person("Azra", "Zukanovic"),
    new Person("Kari", "Pettersen")
};

Optional<Person> resultat = Arrays.stream(personer).max(Comparator.naturalOrder());

resultat.ifPresent(System.out::println);
```
ğŸ”¹ **Forklaring:**  
Ved Ã¥ bruke Stream-APIet kan man finne maksimumselementet i et array av sammenlignbare verdier.  
`Comparator.naturalOrder()` bruker klassens naturlige ordning (fra Comparable).

---

### Oppsummering
NÃ¥r du implementerer et generisk grensesnitt som Comparable<T>:
1. SÃ¸rg for at compareTo() er **transitiv**, **antisymmetrisk**, og **konsistent** med equals().  
2. Overskriv equals() og hashCode() slik at de er **konsistente**.  
3. Implementer toString() for lesbar utskrift.  
4. Test klassen med generiske algoritmer (f.eks. Arrays.sort, Collections.max, Stream.max).
