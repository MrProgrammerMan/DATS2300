---
title: Kap 1.1.3 Algoritmers effektivitet
id: 20250818110609
tags: []
---

# [Kap 1.1.3]([[20250818102829]]) Algoritmers effektivitet
Utover at en skal være korrekt ønsker vi at den skal være effektiv. Effektive algoritmer utføres raskere, men det er viktig å huske på at dette avhenger av både algoritmen i seg selv, men også implementeringen og maskinen den kjører på. En mer nøyaktig måte å måle en algoritme er i antall grunnleggende operasjoner, dvs. operasjoner som ikke kan deles videre opp i mer grunnleggende operasjoner. (Kan ofte sammenlignes med assembly-kode).

## Eksempel

For følgende program:
```rust
fn maks(a: &[i32]) -> usize {
    if a.is_empty() {
        panic!("Tabellen a er tom!");
    }

    let mut m = 0; // indeks til foreløpig største verdi
    for i in 1..a.len() {
        if a[i] > a[m] {
            m = i; // oppdater indeksen
        }
    }

    m // returner indeksen til største verdi
}
```

Vi regner utføringstid basert på størrelsen på input-dataen. I dette tilfellet er n antall tall i arrayet som vi skall finne maksverdien i.
Vi regner for hver operasjon(lengden tid det tar, hvor 1 er konstant og n er avhengig av antall input-elementer):
- Sjekk om a er tom (1)
- Instansier m (1)
- Løkke over i `1..a.len()` (n-1)
- Sammenligningen `a[i] < a[m]` gjøres n-1 ganger (3(n-1))
    - Består av to tabelloperasjoner (2) og én sammenligning (1)
- m oppdateres hvis i er mindre enn forrige runde (x)

Totalt er altså operasjonene som gjøres: $1 + 1 + n - 1 + 3n - 3 + x = 4n - 2 + x$.

x er antall ganger tallet oppdateres. Dette varierer fra 0 til n-1.

## Orden

Man kan bruke dette til å regne ut antallet operasjoner for en gitt input til algoritmen. Det er imidlertid mer nyttig å analysere ytterpunktene i antallet operasjoner som potensielt sett må utføres.

I det store og det hele er vi ikke interessert i hvor raskt algoritmen kjører ved små input-størrelser da dette er ubetydelig. Det vi ønsker å se mest på er hvordan vi kan sammenligne effektiviteten av forskjellige algoritmer, og da er det gjerne effektiviteten ved stor input vi bryr oss om.

Vi ser at uttrykket $4n - 2 + x$ blir til $4n -2 + n - 1 = 5n -3$ i det verst tenkelige scenarioet hvor $x = n - 1$.
Det dominerende leddet her er $n$. Det vil si at hvis vi sammenligner denne algoritmen med en annen algoritme med effektivitet på $3n^2 + 4n - 3$, hvor $n^2$ er det dominerende leddet vil algoritmen med dominerende ledd $n$ garantert være raskere enn den med dominerende ledd $n^2$ **dersom n er stor nok**. Derfor er det det dominernde leddet vi bryr oss om. Vi sier at algoritmen er av orden $n$.

Man betegner ofte dette med Big-O notasjon O(n).