---
title: Kap 1.5.1 Hva er en rekursiv metode?
id: 20251030120106
tags: []
---

# [Kap 1.5.1]([[20250818102829]]) Hva er en rekursiv metode?
En rekursiv metode kaller seg selv. Grunnen til at vi bruker rekursjon er at det i mange situasjoner passer veldig godt til problemet vi skal løse. Koden kan bli kortere og mer elegant. Imidlertid kan rekursiv kode også involvere svært mange rekursive kall, mye minnebruk og kode som er vanskelig å forstå. Alle algoritmer som kan implementeres rekursivt eller iterativt kan implementeres på begge måter.

## Tree traversal
Si at vi ønsker å gå gjennom et tre enten ved preorden, inorden eller postorden(som er kjente måter til vanlige operasjoner på trær). Rekursivt ser koden slik ut:
```java
public static<T> void preorder(Node<T> n, Consumer<? super T> c) {
    if (n == null) return;
    c.accept(n.value);
    preorder(n.left, c);
    preorder(n.right, c);
}

public static<T> void inorder(Node<T> n, Consumer<? super T> c) {
    if (n == null) return;
    inorder(n.left, c);
    c.accept(n.value);
    inorder(n.right, c);
}

public static<T> void postorder(Node<T> n, Consumer<? super T> c) {
    if (n == null) return;
    postorder(n.left, c);
    postorder(n.right, c);
    c.accept(n.value);
}
```
Den iterative koden, derimot:
```java
public static <T> void preorder(Node<T> root, Consumer<? super T> c) {
    if (root == null) return;

    Deque<Node<T>> stack = new ArrayDeque<>();
    stack.push(root);

    while (!stack.isEmpty()) {
        Node<T> node = stack.pop();
        c.accept(node.value); // prosessér noden først (pre)

        // viktig: høyre først slik at venstre behandles først
        if (node.right != null) stack.push(node.right);
        if (node.left != null) stack.push(node.left);
    }
}

public static <T> void inorder(Node<T> root, Consumer<? super T> c) {
    Deque<Node<T>> stack = new ArrayDeque<>();
    Node<T> current = root;

    while (current != null || !stack.isEmpty()) {
        // Gå så langt venstre som mulig
        while (current != null) {
            stack.push(current);
            current = current.left;
        }

        // Hent øverste fra stack og prosesser den
        current = stack.pop();
        c.accept(current.value);

        // Nå må vi til høyre subtre
        current = current.right;
    }
}

public static <T> void postorder(Node<T> root, Consumer<? super T> c) {
    if (root == null) return;

    Deque<Node<T>> stack1 = new ArrayDeque<>();
    Deque<Node<T>> stack2 = new ArrayDeque<>();

    stack1.push(root);

    while (!stack1.isEmpty()) {
        Node<T> node = stack1.pop();
        stack2.push(node);

        if (node.left != null) stack1.push(node.left);
        if (node.right != null) stack1.push(node.right);
    }

    // Nå ligger nodene i "omvendt postorder" i stack2
    while (!stack2.isEmpty()) {
        c.accept(stack2.pop().value);
    }
}
```
De rekursive metodene er enklere å forstå, kortere å skrive og lettere å implementere riktig fordi problemet er nært intuisjonen vi har av de løsningene.

## Fibonacci
Fibonacci-tallene er gjerne definert med en differens-ligning. Dette kan vi enkelt implementere rekursivt:
```java
public static long fib(int n) {
    if (n <= 1) return n;
    return fib(n - 1) + fib(n - 2);
}
```
Den iterative implementasjonen ser slik ut:
```java
public static long fib(int n) {
    if (n <= 1) return n;
    long a = 0, b = 1;
    for (int i = 2; i <= n; i++) {
        long next = a + b;
        a = b;
        b = next;
    }
    return b;
}
```
Selv om den rekursive koden er kortere, kan den være mindre intuitiv enn den iterative. Vi må ofte stole litt på at rekursjonen fungerer, da det er litt svart magi å kun sende problemet videre. Det er imidlertid noen ting vi må huske på for å lage en korrekt rekursiv metode.

## Hvordan lage en korrekt rekursiv metode/algoritme
En rekursiv metode kaller seg selv. For at dette ikke pågår for alltid trenger vi 2 ting:
1. En base case.
2. De rekursive kallene må nærme seg base-casen.
I definisjonen av fib() over er base-casen `if (n <= 1) return n;`. Uten denne er metoden evig rekursiv og produserer aldri noe resultat. I tillegg vil metoden i de rekursive tallene alltid minske n med 1 eller 2. Altså vil n i senere kall bare bli mindre. Dette garanterer at base-casen vår før eller senere inntreffer.

Vi kan altså lage en rekursiv metode dersom vi har en base-case som vi "har svaret på", og en enkel måte å _redusere problemet_. Å finne fibonacci-tall 3 er lettere enn fibonacci-tall 30, og ved å redusere problemet nærmere og nærmere vår kjente base-case(fibonacci-tall 0 og 1), kan vi finne alle tallene ved å jobbe oss bortover listen. Merk at dette er svært likt den typiske differensligningen som definerer fibonacci-tallene fra matematikken. Med 2 ledd vi er avhengige av trenger vi 2 kjente base-caser. Disse har vi kodet inn i if-testen(0 og 1). Det vil ikke forekomme negative tall her så lenge vi forsøker å finne et positivt fibonacci-tall(negative er ulovlig).