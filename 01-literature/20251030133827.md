---
title: Kap 1.5.7 Kvikksortering
id: 20251030133910
tags: []
---

# [1.5.7]([[20250818102829]]) [Kvikksortering]([[20251028131153]])
```java
public static void quicksort(int[] a) {
    quicksort(a, 0, a.length);
}

public static void quicksort(int[] a, int start, int end) {
    if (end - start <= 1) return; // Single element already sorted
    int i = partition(a, start, end); // i is index of pivot
    quicksort(a, start, i); // Quicksort left of pivot
    quicksort(a, i+1, end); // Quicksort right of pivot
}

public static int partition(int[] a, int start, int end) {
    int k = a[start]; // Pivot is first element
    partition(a, start+1, end, k); // Partition the segment of the array based on k, not moving k
    int i = start;
    int j = start + 1;
    while (j < end) {
        if (a[j] < k) {
            a[i] = a[j];
            i++;
            j++;
        } else break;
    }
    a[i] = k; // Restore k in a [i]
    return i; // return index of pivot, now in the correct position
}

public static void partition(int[] a, int start, int end, int k) {
    int l = start; // Left i first element
    int r = end - 1; // Right is last element
    while (l < r) { // As long as l and r are different
        while (l < r && a[l] < k) l++; // As long as l and r are different, move l right to find an incorrect element
        while (l < r && a[r] >= k) r--; // As long as l and r are different, move r left to find an incorrect element
        swap(a, l, r); // Either, l = r and swap does nothing OR l and r are incorrect and need swapping
    }
}
    
public static void swap(int[] arr, int a, int b) {
    int tmp = arr[a];
    arr[a] = arr[b];
    arr[b] = tmp;
}
```

Mer standard implementasjon:
```java
import java.util.Arrays;

class GfG {

    // partition function
    static int partition(int[] arr, int low, int high) {
        
        // choose the pivot
        int pivot = arr[high];
        
        // index of smaller element and indicates 
        // the right position of pivot found so far
        int i = low - 1;

        // traverse arr[low..high] and move all smaller
        // elements to the left side. Elements from low to 
        // i are smaller after every iteration
        for (int j = low; j <= high - 1; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        // Move pivot after smaller elements and
        // return its position
        swap(arr, i + 1, high);  
        return i + 1;
    }

    // swap function
    static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    // the QuickSort function implementation
    static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            
            // pi is the partition return index of pivot
            int pi = partition(arr, low, high);

            // recursion calls for smaller elements
            // and greater or equals elements
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }

    public static void main(String[] args) {
        int[] arr = {10, 7, 8, 9, 1, 5};
        int n = arr.length;
      
        quickSort(arr, 0, n - 1);
        
        for (int val : arr) {
            System.out.print(val + " ");  
        }
    }
}
```