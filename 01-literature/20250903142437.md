---
title: Forelesning 03.09
id: 20250903142448
tags: []
---

# Forelesning 03.09

## Fletting
Hvis vi slår sammen to lister ved å ta verdier _alternerende_ og legger i en resultatliste, sier vi at vi fletter listene.
Eks: Liste 1: [2, 4, 1, 7, 13] Liste 2: [5, 12, 9, 8, 3]
Vi fletter listene til: [2, 5, 4, 12, 1, 9, 7, 8, 13, 3]

Hvis listene har forskjellig lengde må vi fylle på de siste verdiene i listen som er lenger til slutt.
Eks: Liste 1: [2, 4, 1, 7, 13] Liste 2: [5, 12, 9, 8, 3, 6, 7, 8, 43, 1]
Vi fletter listene til: [2, 5, 4, 12, 1, 9, 7, 8, 13, 3, 6, 7, 8, 43, 1]

Vi kan implementere fletting av lister med tall slik:
```rust
fn flett(a: &[i32], b: &[i32]) -> Vec<i32> {
    let mut i = 0;
    let mut res = Vec::with_capacity(a.len() + b.len());
    while i < a.len() && i < b.len() {
        res.push(a[i]);
        res.push(b[i]);
        i += 1;
    }
    
	res.extend_from_slice(&a[i..]);
	res.extend_from_slice(&b[i..]);
    
    res
}
```

### Fletting av sorterte lister
Vi kan ta to lister og sortere par fra listene mens vi fletter. For hvert par bestående av et element fra a og et element fra b, vil disse være korrekt sortert i resultatet. Dersom listene vi startet med var riktig sortert, vil den flettede listen også være sortert.

```rust
fn flette_sortering(a: &[i32], b: &[i32]) -> Vec<i32> {
    let mut i = 0;
    let mut j = 0;
    let mut res = Vec::new();
    while i < a.len() && j < b.len() {
        if a[i] < b[j] {
        	res.push(a[i]);
        	i += 1;    
        } else {
            res.push(b[j]);
            j += 1;
        }
    }

    res.extend_from_slice(&a[i..]);
	res.extend_from_slice(&b[j..]);
    
    res
}
```

## Flettesortering
Basert på teknikken over kan vi lage en sorteringsalgoritme. Vi vet at en liste med ett element er sortert. Derfor kan vi enkelt definere en rekursiv algoritme som deler opp en liste til vi har atomære deler, som så kan flettesorteres til vi har sortert hele input-listen.
```rust
fn merge_sort(a: &[i32]) -> Vec<i32> {
    if a.len() <= 1 {
        Vec::from(a)
    } else {
        let pivot = (a.len() / 2) as usize;
        flette_sortering(merge_sort(a[..pivot]), merge_sort(a[pivot..]))
    }
}
```

## Forskyvninger
En forskyvning (eng. _shift_) betyr at vi flytter alle elementene i en liste ett eller flere steg i en bestemt retning.  
Vi skiller gjerne mellom **venstreforskyvning** og **høyreforskyvning**:

- **Venstreforskyvning:** Alle elementene flyttes én posisjon mot venstre. Det første elementet faller ut, og de andre flytter seg fram.  
  Eks: `[2, 4, 6, 8]` → `[4, 6, 8]`  

- **Høyreforskyvning:** Alle elementene flyttes én posisjon mot høyre. Det siste elementet faller ut.  
  Eks: `[2, 4, 6, 8]` → `[2, 4, 6]`  

Forskyvning fjerner altså element(er) i den ene enden og gjør listen kortere dersom vi ikke fyller på nye verdier. Ofte brukes forskyvning i sammenheng med køer (der vi fjerner fra starten) eller buffere (der vi skyver elementer innover for å gjøre plass).

En enkel implementasjon av **venstreforskyvning** kan være:
```rust
fn forskyv_venstre(mut a: Vec<i32>) -> Vec<i32> {
    if !a.is_empty() {
        a.remove(0); // fjerner første element
    }
    a
}
```

## Rotasjoner
En rotasjon ligner på en forskyvning, men her "beholder" vi elementene ved å flytte dem rundt slik at de som faller ut på den ene siden dukker opp igjen på den andre siden.  
Vi kan også her skille mellom **venstrerotasjon** og **høyre-rotasjon**:

- **Venstrerotasjon:** Første element flyttes til slutten av listen.  
  Eks: `[2, 4, 6, 8]` → `[4, 6, 8, 2]`

- **Høyrerotasjon:** Siste element flyttes til starten av listen.  
  Eks: `[2, 4, 6, 8]` → `[8, 2, 4, 6]`

Dette kan være nyttig i mange algoritmer, f.eks. rundkjøringer i datastrukturer, rotering av matriser eller simulering av sirkulære køer.

En enkel implementasjon av **venstrerotasjon** kan være:
```rust
fn roter_venstre(mut a: Vec<i32>) -> Vec<i32> {
    if !a.is_empty() {
        let first = a.remove(0);
        a.push(first);
    }
    a
}
```

En mer effektiv implementasjon kan bruke **slicing** i stedet for `remove`, siden `remove` har lineær kostnad:
```rust
fn roter_venstre_slice(a: &[i32]) -> Vec<i32> {
    if a.is_empty() {
        Vec::new()
    } else {
        let (first, rest) = a.split_at(1);
        [rest, first].concat()
    }
}
```